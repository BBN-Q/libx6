import socket
import struct
import unittest as ut

import numpy as np

import libx6

class TestSettersGetters(ut.TestCase):
    """
    Test reading and writing wishbone registers.
    """

    @classmethod
    def setUpClass(cls):
        cls.x6 = libx6.X6()
        cls.x6.connect(0)

    @classmethod
    def tearDownClass(cls):
        cls.x6.disconnect()

    def test_wishbone_readwrite(self):
        """ check that we can write and read the wishbone bus """
        val = np.random.randint(2**32-1, dtype=np.uint32)
        self.x6.write_register(libx6.QDSP_WB_OFFSET[0], 2, val)
        check_val = self.x6.read_register(libx6.QDSP_WB_OFFSET[0], 2)
        self.assertEqual(val, check_val, "wishbone register read did not match value written")

    def test_temperature(self):
        """test that we can read the temperature and it's sane"""
        temp = self.x6.get_logic_temperature()
        self.assertTrue( (temp > 20) and (temp < 80), "FPGA temperature seems fishy")

    def test_record_length_validators(self):
        """ test that exceptions are thrown for invalid record lengths"""
        # minimum of 128
        self.x6.record_length = 96
        self.assertRaisesRegex(Exception, "LIBX6 Error: -8", self.x6.set_averager_settings)

        # maximum of 16384
        self.x6.record_length = 16448
        self.assertRaisesRegex(Exception, "LIBX6 Error: -8", self.x6.set_averager_settings)

        # record length should be a multiple of 128
        self.x6.record_length = 320
        self.assertRaisesRegex(Exception, "LIBX6 Error: -8", self.x6.set_averager_settings)

    def test_nco_frequency(self):
        """ test setter/getter for NCO frequency """
        test_freq = np.random.randint(125e6)
        self.x6.set_nco_frequency(1, 1, test_freq)
        check_freq = self.x6.get_nco_frequency(1, 1)
        # don't expect more than 24 bits precision on a quarter sampling rate
        self.assertAlmostEqual(test_freq, check_freq, delta=1e9 / 4 / 2**24)

def expected_raw_wfs():
    """ Returns the raw test pattern generated by the gateware. """
    expected = np.zeros((1280, 64), dtype=np.float64)
    for ct in range(64):
        baseNCO = 1.0000020265579224e6; # from 24bit precision
        pulse = (1 - 1/128) * (1 - 1/2048) * np.cos(2*np.pi*(ct % 64)*baseNCO*1e-9*(np.arange(8,4108)))
        expected[23:23+pulse.size//4, ct] = np.mean(pulse.reshape((4, pulse.size//4), order="F"), axis=0)
        # catch alignment marker
        if ct % 64 == 0:
            expected[3:7,ct] = 1 - 1/2048
    return expected

def enable_test_mode(x6, interval):
    """ write the test register setting the enable bit and interval """
    # internal trigger generator runs of 250 MHz clock
    x6.write_register(libx6.QDSP_WB_OFFSET[0], 1, (1 << 16) + (int(interval * 250e6) & 0xffff))
    x6.write_register(libx6.QDSP_WB_OFFSET[1], 1, (1 << 16) + (int(interval * 250e6) & 0xffff))

class TestStreams(ut.TestCase):
    """
    Test reading data streams
    """

    def setUp(self):
        self.x6 = libx6.X6()
        self.addCleanup(self.x6.disconnect)
        self.x6.connect(0)

    def test_raw_streams(self):
        """ Check the pattern on the raw streams """

        libx6.set_logging_level(8)

        # enable the two raw streams
        self.x6.enable_stream(1, 0, 0)
        self.x6.enable_stream(2, 0, 0)
        streams = [(1,0,0), (2,0,0)]

        self.x6.record_length = 5120
        self.x6.nbr_segments = 64
        self.x6.nbr_waveforms = 1
        self.x6.nbr_round_robins = 1

        self.x6.acquire_mode = "digitizer"

        sockets = {}

        for s in streams:
            sockets[s] = socket.socketpair()
            self.x6.register_socket(*s, sockets[s][1])

        self.x6.acquire()

        enable_test_mode(self.x6, 100e-6)

        data = {}
        idx = {}
        for s in streams:
            idx[s] = 0
            data[s] = np.empty(self.x6.record_length//4 * self.x6.nbr_segments, dtype=np.float64)

        while True:
            # TODO: timeout
            all_done = all(idx[s] == data[s].size for s in streams)
            if (not self.x6.get_is_running()) or all_done:
                break

            for s in streams:
                if idx[s] < data[s].size:
                    msg = sockets[s][0].recv(8)
                    msg_size = struct.unpack('n', msg)[0]
                    buf = sockets[s][0].recv(msg_size, socket.MSG_WAITALL)
                    num_points = msg_size // np.dtype(np.float64).itemsize
                    data[s][idx[s]:idx[s]+num_points] = np.frombuffer(buf, dtype=np.float64)
                    idx[s] += num_points

        for sp in sockets.values():
            sp[0].close()
            sp[1].close()

        for s in streams:
            data[s] = data[s].reshape(self.x6.record_length //4, self.x6.nbr_segments, order="F")

        expected = expected_raw_wfs()

        for s in streams:
            np.testing.assert_allclose(data[s], expected, atol=2/2048, err_msg="Raw stream {} failed to match expected".format(s))

if __name__ == '__main__':
    ut.main()
